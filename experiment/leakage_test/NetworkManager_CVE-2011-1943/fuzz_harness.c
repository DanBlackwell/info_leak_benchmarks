#include "nm-setting-vpn.h"
#include <stdio.h>
#include <stdint.h>
#include <unistd.h>
#include <glib.h>

#ifdef DFSAN
#  include <sanitizer/dfsan_interface.h>
#  include <assert.h>
#endif

#if !defined VANILLA_AFL && !defined DFSAN
  #include "decode_inputs.h"
  #include "memory.h"
#endif

#ifdef DFSAN
  dfsan_label secret_label = 1;
#endif

GType nm_setting_connection_get_type() {
  return 1;
}


char *fetchString(int minLen, int maxLen, const unsigned char *buf, int bufLen, int *bufPos) {
  if (*bufPos == bufLen) {
    char *string = calloc(1, 1);
    return string;
  }

  int stringLen = buf[*bufPos] % (maxLen - minLen) + minLen; // select len between 5 and 20
  (*bufPos)++;
  stringLen = bufLen - *bufPos >= stringLen ? stringLen : bufLen - *bufPos;

  char *string = calloc(stringLen + 1, 1);
  memcpy(string, buf + *bufPos, stringLen);
  (*bufPos) += stringLen;

  return string;
}

void logFunc(const gchar *log_domain,
             GLogLevelFlags log_level,
             const gchar *message,
             gpointer user_data) 
{
  switch (log_level) {
	  case G_LOG_FLAG_RECURSION:
		  printf("RECURSION: "); break;
	  case G_LOG_FLAG_FATAL:
		  printf("FATAL: "); break;
	  case G_LOG_LEVEL_ERROR:
		  printf("ERROR: "); break;
	  case G_LOG_LEVEL_CRITICAL:
		  printf("CRITICAL: "); break;
	  case G_LOG_LEVEL_WARNING:
		  printf("WARNING: "); break;
	  case G_LOG_LEVEL_MESSAGE:
		  printf("MESSAGE: "); break;
	  case G_LOG_LEVEL_INFO:
		  printf("INFO: "); break;
	  case G_LOG_LEVEL_DEBUG:
		  printf("DEBUG: "); break;
	  case G_LOG_LEVEL_MASK:
		  printf("MASK: "); break;
  }

#ifdef DFSAN
  assert(!dfsan_has_label(dfsan_read_label(message, strlen(message)), secret_label));
#endif

  printf("%s\n", message);
}

#ifdef DFSAN
int main(void) {

    char *Data = (char *)malloc(1024*1024+1);
    int length = read(STDIN_FILENO, Data, 1024*1024+1);
    if (length == -1 || length == 1024*1024+1) {
        printf("Error! too long\n");
        exit(1);
    }
#else
extern "C" int LLVMFuzzerTestOneInput(const uint8_t *Data, uint32_t length) {
#endif

  g_log_set_default_handler(logFunc, NULL);

  NMSetting *setting;

  setting = nm_setting_vpn_new();

#if defined VANILLA_AFL || defined DFSAN
  uint8_t *public_in = Data;
  uint32_t public_len = length / 2;
  uint8_t *secret_in = Data + public_len;
  uint32_t secret_len = length - public_len;

#else
  uint8_t *public_in, *secret_in;
  uint32_t public_len, secret_len;
  find_public_and_secret_inputs(buf, len, &public_in, &public_len, &secret_in, &secret_len);
  if (!public_in || !secret_in) {
    printf("Failed to parse public / secret inputs JSON (expected \'{\"PUBLIC\": \"base64_input\", \"SECRET\": \"base64_input\"}\')\n");
    return 1;
  }

  uint32_t seed = 0;
  for (int i = 0; i < (secret_len < 4 ? secret_len : 4); i++) {
      seed |= secret_in[i] << 8 * i;
  }
#endif
 
  int pub_pos = 0, sec_pos = secret_len < 4 ? secret_len : 4;

#ifdef DFSAN
  dfsan_set_label(secret_label, secret_in, secret_len);
#endif

#if !defined VANILLA_AFL && !defined DFSAN
  SEED_MEMORY(seed);
  fill_stack();
#endif

  while (pub_pos < public_len) {
    int fn = public_in[pub_pos++] % 7;
 
    switch(fn) {
      case 0:
        printf("user_name: %s\n", nm_setting_vpn_get_user_name(setting));
        break;
      case 1:
        printf("service_type: %s\n", nm_setting_vpn_get_service_type(setting));
        break;
      case 2:
        {
        char *key = fetchString(5, 20, public_in, public_len, &pub_pos);
        char *item = fetchString(5, 20, public_in, public_len, &pub_pos);
        //printf("adding item %s: %s\n", key, item);
        nm_setting_vpn_add_data_item(setting, key, item);
        free(key);
        free(item);
        }
        break;
      case 3:
        {
        char *key = fetchString(5, 20, public_in, public_len, &pub_pos);
        //printf("item %s: %s\n", key, nm_setting_vpn_get_data_item(setting, key));
        free(key);
        }
        break;
      case 4:
        {
        char *key = fetchString(5, 20, public_in, public_len, &pub_pos);
        //printf("removing item %s\n", key);
        nm_setting_vpn_remove_data_item(setting, key);
        free(key);
        }
        break;
      case 5:
        {
        char *key = fetchString(5, 20, public_in, public_len, &pub_pos);
        char *item = fetchString(5, 20, secret_in, secret_len, &sec_pos);
        //printf("adding secret %s: %s\n", key, item);
        nm_setting_vpn_add_secret(setting, key, item);
        free(key);
        free(item);
        }
        break;
      case 6:
        {
        char *key = fetchString(5, 20, public_in, public_len, &pub_pos);
        //printf("removing secret %s\n", key);
        nm_setting_vpn_remove_secret(setting, key);
        free(key);
        }
        break;
    }
  }
  
}
