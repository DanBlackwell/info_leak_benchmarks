#include "nm-setting-vpn.h"
#include <stdio.h>
#include <stdint.h>
#include <unistd.h>
#include <glib.h>
#include <assert.h>

char *program_output = NULL;
size_t program_output_len = 512;
int program_output_pos;
#define MOCK_PRINTF(...) { \
  if (!program_output) { program_output = malloc(program_output_len); if (!program_output) exit(1); } \
  int success = 0; \
  do { \
    int available = program_output_len - program_output_pos - 1; \
    int res = snprintf(program_output + program_output_pos, available, __VA_ARGS__); \
    if (res >= available) { \
      program_output_len *= 2; \
      program_output = realloc(program_output, program_output_len); \
      if (!program_output) exit(1); \
    } else { \
      success = 1; \
      program_output_pos += res; \
    } \
  } while(!success); \
}

#ifdef DFSAN
  dfsan_label secret_label = 1;
#endif

GType nm_setting_connection_get_type() {
  return 1;
}

void logFunc(const gchar *log_domain,
             GLogLevelFlags log_level,
             const gchar *message,
             gpointer user_data) 
{
  switch (log_level) {
	  case G_LOG_FLAG_RECURSION:
		  MOCK_PRINTF("RECURSION: "); break;
	  case G_LOG_FLAG_FATAL:
		  MOCK_PRINTF("FATAL: "); break;
	  case G_LOG_LEVEL_ERROR:
		  MOCK_PRINTF("ERROR: "); break;
	  case G_LOG_LEVEL_CRITICAL:
		  MOCK_PRINTF("CRITICAL: "); break;
	  case G_LOG_LEVEL_WARNING:
		  MOCK_PRINTF("WARNING: "); break;
	  case G_LOG_LEVEL_MESSAGE:
		  MOCK_PRINTF("MESSAGE: "); break;
	  case G_LOG_LEVEL_INFO:
		  MOCK_PRINTF("INFO: "); break;
	  case G_LOG_LEVEL_DEBUG:
		  MOCK_PRINTF("DEBUG: "); break;
	  case G_LOG_LEVEL_MASK:
		  MOCK_PRINTF("MASK: "); break;
  }

  MOCK_PRINTF("%s\n", message);
}

void run_funcs(char *secret, char fn1, char fn2) {
  NMSetting *setting;
  setting = nm_setting_vpn_new();

#define INPUTS_LEN 3
  char public1[INPUTS_LEN];
  public1[INPUTS_LEN - 1] = 0;
  char public2[INPUTS_LEN];
  public2[INPUTS_LEN - 1] = 0;

  int i = 0;
  while (i < 2) {
    switch(((i % 2) == 0 ? fn1 : fn2) % 7) {
      case 0:
        MOCK_PRINTF("user_name: %s\n", nm_setting_vpn_get_user_name(setting));
        break;
      case 1:
        MOCK_PRINTF("service_type: %s\n", nm_setting_vpn_get_service_type(setting));
        break;
      case 2:
        {
        char *key = public1;
        char *item = public2;
        nm_setting_vpn_add_data_item(setting, key, item);
        }
        break;
      case 3:
        {
        char *key = public1;
        MOCK_PRINTF("item %s: %s\n", key, nm_setting_vpn_get_data_item(setting, key));
        }
        break;
      case 4:
        {
        char *key = public1;
        nm_setting_vpn_remove_data_item(setting, key);
        }
        break;
      case 5:
        {
        char *key = public1;
        char *item = secret;
        nm_setting_vpn_add_secret(setting, key, item);
        }
        break;
      case 6:
        {
        char *key = public1;
        nm_setting_vpn_remove_secret(setting, key);
        }
        break;
    }
    i++;
  }
}

void cbmc_test() {
  g_log_set_default_handler(logFunc, NULL);

#define INPUTS_LEN 3
  char secret1[INPUTS_LEN], secret2[INPUTS_LEN];
  secret1[INPUTS_LEN - 1] = secret2[INPUTS_LEN - 1] = 0;

  char fn1, fn2;

  run_funcs(secret1, fn1, fn2);

  char *output1 = malloc(program_output_pos + 1);
  memcpy(output1, program_output, program_output_pos);
  output1[program_output_pos] = 0;
  // Reset the program output
  program_output_pos = 0;

  run_funcs(secret2, fn1, fn2);

  assert(!strcmp(output1, program_output));
}
