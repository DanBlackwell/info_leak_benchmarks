#include <libpq-fe.h>
#include <stdint.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>

char *program_output = NULL;
size_t program_output_len = 256;
int program_output_pos;
#define MOCK_PRINTF(...) { \
  if (!program_output) { program_output = malloc(program_output_len); if (!program_output) exit(1); } \
  int success = 0; \
  do { \
    int available = program_output_len - program_output_pos - 1; \
    int res = snprintf(program_output + program_output_pos, available, __VA_ARGS__); \
    if (res >= available) { \
      program_output_len *= 2; \
      program_output = realloc(program_output, program_output_len); \
      if (!program_output) exit(1); \
    } else { \
      success = 1; \
      program_output_pos += res; \
    } \
  } while(!success); \
}

static PGconn *conn = NULL;

int run_cmd(const char *cmd, int printResult, int silentErrors) {
  if (!conn) {
    conn = PQconnectdb(""); //"user = 'postgres'");
  }


  PGresult *result = PQexec(conn, cmd);
  if (!result) {
    if (!silentErrors) {
      MOCK_PRINTF("  fatal error fetching result for '%s'\n", cmd);
      char *errMsg = PQerrorMessage(conn);
      MOCK_PRINTF("  PQErrorMessage: '%s'\n", errMsg);
    }
    PQclear(result);
    return 1;
  }


  ExecStatusType resStat = PQresultStatus(result);
  if (resStat != PGRES_COMMAND_OK) {
    // printf("  Received result: %d, error message: %s\n", resStat, PQerrorMessage(conn));
    if (!silentErrors) {
      MOCK_PRINTF("Ran '%s'\n", cmd);
      char *errMsg = PQerrorMessage(conn);
      MOCK_PRINTF("%s", errMsg);
    }
    PQclear(result);
    return 1;
  }

  if (printResult) {
    PQprintOpt printOpt = {
          .header = 1,
          .align = 0,
          .standard = 0,
          .html3 = 0,
          .expanded = 1,
          .pager = 1,
          .fieldSep = ",",
          .tableOpt = NULL,
          .caption = NULL,
          .fieldName = NULL
    };
  
    PQprint(stdout, result, &printOpt);
  }

  PQclear(result);

  return 0;
}

void reset_conn() {
  PQfinish(conn);
  conn = NULL;
}

#define RUN_OR_BAIL(cmd) do { int ret = cmd; if (ret) { reset_conn(); sleep(5); return 1; } } while(0);

int cbmc_test() {
  int printRes = 0;
  int silentErrors = 1;
  RUN_OR_BAIL(run_cmd("DROP TABLE IF EXISTS errtst", printRes, silentErrors););

  run_cmd("DROP USER IF EXISTS high", printRes, silentErrors);
  run_cmd("DROP USER IF EXISTS low", printRes, silentErrors);
  run_cmd("CREATE USER high", printRes, silentErrors);
  run_cmd("CREATE USER low", printRes, silentErrors);

  run_cmd("CREATE TABLE errtst(a text, b text NOT NULL, c text, secret1 text, secret2 text) PARTITION BY LIST (a);", printRes, silentErrors);
  run_cmd("CREATE TABLE errtst_part_1(secret2 text, c text, a text, b text NOT NULL, secret1 text);", printRes, silentErrors);
  run_cmd("CREATE TABLE errtst_part_2(secret1 text, secret2 text, a text, c text, b text NOT NULL);", printRes, silentErrors);

  run_cmd("ALTER TABLE errtst ATTACH PARTITION errtst_part_1 FOR VALUES IN ('aaa');", printRes, silentErrors);
  run_cmd("ALTER TABLE errtst ATTACH PARTITION errtst_part_2 FOR VALUES IN ('aaaa');", printRes, silentErrors);

  run_cmd("GRANT SELECT (a, b, c) ON TABLE errtst TO low;", printRes, silentErrors);
  run_cmd("GRANT UPDATE (a, b, c) ON TABLE errtst TO low;", printRes, silentErrors);
  run_cmd("GRANT INSERT (a, b, c) ON TABLE errtst TO low;", printRes, silentErrors);

  silentErrors = 1;

  RUN_OR_BAIL(run_cmd("SET SESSION AUTHORIZATION DEFAULT", printRes, silentErrors));
  RUN_OR_BAIL(run_cmd("DELETE FROM errtst_part_1;", printRes, silentErrors));

  char secret1[20], secret2[20];
  secret1[19] = secret2[19] = 0; // terminate the strings
  
  char command[256];
  sprintf(command, "INSERT INTO errtst_part_1 (a, b, c, secret1, secret2) VALUES ('aaa', 'low2', 'low3', '%s', '%s');", secret1, secret2);

  int res = run_cmd(command, printRes, silentErrors);

  if (res) { goto cleanup; }

  silentErrors = 0;

  run_cmd("SET SESSION AUTHORIZATION low", printRes, silentErrors);

  char commands[256];
  char *token = strtok(commands, ";");
  while (token) {
    run_cmd(token, 0, silentErrors);
    token = strtok(NULL, ";");
  }

  char *output1 = malloc(program_output_pos);
  int output1_len = program_output_pos;
  memcpy(output1, program_output, program_output_pos);
  program_output_pos = 0;

  char secret3[20], secret4[20];
  secret3[19] = secret4[19] = 0; // terminate the strings
  
  RUN_OR_BAIL(run_cmd("SET SESSION AUTHORIZATION DEFAULT", printRes, silentErrors));
  RUN_OR_BAIL(run_cmd("DELETE FROM errtst_part_1;", printRes, silentErrors));
  sprintf(command, "INSERT INTO errtst_part_1 (a, b, c, secret1, secret2) VALUES ('aaa', 'low2', 'low3', '%s', '%s');", secret3, secret4);

  run_cmd("SET SESSION AUTHORIZATION low", printRes, silentErrors);

  char commands2[256];
  char *token = strtok(commands2, ";");
  while (token) {
    run_cmd(token, 0, silentErrors);
    token = strtok(NULL, ";");
  }

  assert(program_output_pos == output1_len);
  assert(!memcmp(program_output, output1, program_output_pos));

cleanup:
  reset_conn();
  return 0;
}

