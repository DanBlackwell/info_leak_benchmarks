#include <libpq-fe.h>
#include <stdint.h>
#include <unistd.h>
#include <string.h>
#include <stdlib.h>

#ifdef VANILLA_AFL
#  define DFSAN
#endif 

#ifdef DFSAN
#  include <sanitizer/dfsan_interface.h>
#  include <assert.h>
#endif

#ifndef DFSAN
  #include "memory.h"
  #include "decode_inputs.h"
#endif

#ifdef DFSAN
  dfsan_label secret_label = 1;
#endif

static PGconn *conn = NULL;

int run_cmd(const char *cmd, int printResult, int silentErrors) {
  if (!conn) {
    conn = PQconnectdb(""); //"user = 'postgres'");
  }


  PGresult *result = PQexec(conn, cmd);
  if (!result) {
    if (!silentErrors) {
      printf("  fatal error fetching result for '%s'\n", cmd);
      char *errMsg = PQerrorMessage(conn);
#ifdef DFSAN
      assert(!dfsan_has_label(dfsan_read_label(errMsg, strlen(errMsg)), secret_label));
#endif
      printf("  PQErrorMessage: '%s'\n", errMsg);
    }
    PQclear(result);
    return 1;
  }


  ExecStatusType resStat = PQresultStatus(result);
  if (resStat != PGRES_COMMAND_OK) {
    // printf("  Received result: %d, error message: %s\n", resStat, PQerrorMessage(conn));
    if (!silentErrors) {
      printf("Ran '%s'\n", cmd);
      char *errMsg = PQerrorMessage(conn);
#ifdef DFSAN
      assert(!dfsan_has_label(dfsan_read_label(errMsg, strlen(errMsg)), secret_label));
#endif
      printf("%s", errMsg);
    }
    PQclear(result);
    return 1;
  }

  if (printResult) {
    PQprintOpt printOpt = {
          .header = 1,
          .align = 0,
          .standard = 0,
          .html3 = 0,
          .expanded = 1,
          .pager = 1,
          .fieldSep = ",",
          .tableOpt = NULL,
          .caption = NULL,
          .fieldName = NULL
    };
  
    PQprint(stdout, result, &printOpt);
  }

  PQclear(result);

  return 0;
}

void reset_conn() {
  PQfinish(conn);
  conn = NULL;
}

#define RUN_OR_BAIL(cmd) do { int ret = cmd; if (ret) { reset_conn(); usleep(500000); return 1; } } while(0);

__AFL_FUZZ_INIT();

// int LLVMFuzzerTestOneInput(uint8_t *data, size_t len) {
int main(void) {
  __AFL_INIT();
  uint8_t *data = __AFL_FUZZ_TESTCASE_BUF;
  uint32_t len = __AFL_FUZZ_TESTCASE_LEN;

  int printRes = 0;
  int silentErrors = 1;
  RUN_OR_BAIL(run_cmd("DROP TABLE IF EXISTS errtst", printRes, silentErrors););

  run_cmd("DROP USER IF EXISTS high", printRes, silentErrors);
  run_cmd("DROP USER IF EXISTS low", printRes, silentErrors);
  run_cmd("CREATE USER high", printRes, silentErrors);
  run_cmd("CREATE USER low", printRes, silentErrors);

  run_cmd("CREATE TABLE errtst(a text, b text NOT NULL, c text, secret1 text, secret2 text) PARTITION BY LIST (a);", printRes, silentErrors);
  run_cmd("CREATE TABLE errtst_part_1(secret2 text, c text, a text, b text NOT NULL, secret1 text);", printRes, silentErrors);
  run_cmd("CREATE TABLE errtst_part_2(secret1 text, secret2 text, a text, c text, b text NOT NULL);", printRes, silentErrors);

  run_cmd("ALTER TABLE errtst ATTACH PARTITION errtst_part_1 FOR VALUES IN ('aaa');", printRes, silentErrors);
  run_cmd("ALTER TABLE errtst ATTACH PARTITION errtst_part_2 FOR VALUES IN ('aaaa');", printRes, silentErrors);

  run_cmd("GRANT SELECT (a, b, c) ON TABLE errtst TO low;", printRes, silentErrors);
  run_cmd("GRANT UPDATE (a, b, c) ON TABLE errtst TO low;", printRes, silentErrors);
  run_cmd("GRANT INSERT (a, b, c) ON TABLE errtst TO low;", printRes, silentErrors);

  silentErrors = 1;

  RUN_OR_BAIL(run_cmd("SET SESSION AUTHORIZATION DEFAULT", printRes, silentErrors));
  RUN_OR_BAIL(run_cmd("DELETE FROM errtst_part_1;", printRes, silentErrors));

  uint8_t *public_in, *secret_in;
  uint32_t public_len, secret_len;
#ifdef DFSAN
  public_in = data;
  public_len = len / 2;
  secret_in = data + public_len;
  secret_len = len - public_len;
#else
  find_public_and_secret_inputs((const char *)data, len, &public_in, &public_len, &secret_in, &secret_len);
  if (!public_in || !secret_in) {
    printf("Failed to parse public / secret inputs JSON (expected \'{\"PUBLIC\": \"base64_input\", \"SECRET\": \"base64_input\"}\')\n");
    free(public_in);
    free(secret_in);
    reset_conn();
    return 1;
  }
#endif

#ifdef DFSAN
  dfsan_set_label(secret_label, secret_in, secret_len);
#endif


  char *secret1 = malloc(secret_len + 1);
  char *secret2 = malloc(secret_len + 1);

  int pos = 0;
  for (int i = 0; i < secret_len / 2; i++) {
    char cur = secret_in[pos];
    if (cur == '\'') { 
      secret1[pos++] = '\'';
    }
    secret1[pos++] = cur;
  }
  secret1[pos] = 0;

  pos = 0;
  for (int i = secret_len / 2; i < secret_len; i++) {
    char cur = secret_in[pos];
    if (cur == '\'') { 
      secret2[pos++] = '\'';
    }
    secret2[pos++] = cur;
  }
  secret2[pos] = 0;
  
  char *command = malloc(secret_len + 200);
  sprintf(command, "INSERT INTO errtst_part_1 (a, b, c, secret1, secret2) VALUES ('aaa', 'low2', 'low3', '%s', '%s');", secret1, secret2);

  int res = run_cmd(command, printRes, silentErrors);

  free(command);
  free(secret1);
  free(secret2);

  if (res) { goto cleanup; }

  silentErrors = 0;

  run_cmd("SET SESSION AUTHORIZATION low", printRes, silentErrors);

  char *commands = malloc(public_len + 1);
  memcpy(commands, public_in, public_len);
  commands[public_len] = 0;

  char *token = strtok(commands, ";");
  while (token) {
    run_cmd(token, 0, silentErrors);
    token = strtok(NULL, ";");
  }

  free(commands);
cleanup:
#ifndef VANILLA_AFL
  free(public_in);
  free(secret_in);
#endif

  fflush(stdout);
  reset_conn();
  return 0;
}

