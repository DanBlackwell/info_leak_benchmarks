#include <libpq-fe.h>

int run_cmd(const char *cmd, int printResult) {
  static PGconn *conn = NULL;
  if (!conn) {
    conn = PQconnectdb(""); //"user = 'postgres'");
 //   printf("Connected: %d\n", PQstatus(conn));
  }

//  printf("Ran '%s'\n", cmd);

  PGresult *result = PQexec(conn, cmd);
  if (!result) {
    printf("  fatal error fetching result for '%s'\n", cmd);
    printf("  PQErrorMessage: '%s'\n", PQerrorMessage(conn));
    exit(1);
    return 1;
  }


  ExecStatusType resStat = PQresultStatus(result);
  if (resStat) {
    // printf("  Received result: %d, error message: %s\n", resStat, PQerrorMessage(conn));
    printf("%s", PQerrorMessage(conn));
  }

  if (printResult) {
    PQprintOpt printOpt = {
          .header = 1,
          .align = 0,
          .standard = 0,
          .html3 = 0,
          .expanded = 1,
          .pager = 1,
          .fieldSep = ",",
          .tableOpt = NULL,
          .caption = NULL,
          .fieldName = NULL
    };
  
    PQprint(stdout, result, &printOpt);
  }

  return 0;
}


int main(void) {

  int printRes = 0;
  run_cmd("DROP TABLE IF EXISTS errtst", printRes);

  run_cmd("DROP USER IF EXISTS high", printRes);
  run_cmd("DROP USER IF EXISTS low", printRes);
  run_cmd("CREATE USER high", printRes);
  run_cmd("CREATE USER low", printRes);

  run_cmd("CREATE TABLE errtst(a text, b text NOT NULL, c text, secret1 text, secret2 text) PARTITION BY LIST (a);", printRes);
  run_cmd("CREATE TABLE errtst_part_1(secret2 text, c text, a text, b text NOT NULL, secret1 text);", printRes);
  run_cmd("CREATE TABLE errtst_part_2(secret1 text, secret2 text, a text, c text, b text NOT NULL);", printRes);

  run_cmd("ALTER TABLE errtst ATTACH PARTITION errtst_part_1 FOR VALUES IN ('aaa');", printRes);
  run_cmd("ALTER TABLE errtst ATTACH PARTITION errtst_part_2 FOR VALUES IN ('aaaa');", printRes);
  run_cmd("GRANT SELECT (a, b, c) ON TABLE errtst TO low;", printRes);
  run_cmd("GRANT UPDATE (a, b, c) ON TABLE errtst TO low;", printRes);
  run_cmd("GRANT INSERT (a, b, c) ON TABLE errtst TO low;", printRes);

  run_cmd("INSERT INTO errtst_part_1 (a, b, c, secret1, secret2) VALUES ('low1', 'low2', 'low3', 'secret1', 'secret2');", printRes);

  run_cmd("SET SESSION AUTHORIZATION low", printRes);

  // simple insert.
  run_cmd("INSERT INTO errtst (a, b) VALUES ('aaa', NULL);", printRes);
  // simple update.
  run_cmd("UPDATE errtst SET b = NULL;", printRes);
  // partitioning key is updated, doesn't move the row.
  run_cmd("UPDATE errtst SET a = 'aaa', b = NULL;", printRes);
  // row is moved to another partition.
  run_cmd("UPDATE errtst SET a = 'aaaa', b = NULL;", printRes);

  // row is moved to another partition. This differs from the previous case in
  // that the new partition is excluded by constraint exclusion, so its
  // ResultRelInfo is not created at ExecInitModifyTable, but needs to be
  // constructed on the fly when the updated tuple is routed to it.
  run_cmd("UPDATE errtst SET a = 'aaaa', b = NULL WHERE a = 'aaa';", printRes);

  return 0;
}

