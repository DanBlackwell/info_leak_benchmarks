#include <libpq-fe.h>
#include <stdint.h>
#include <unistd.h>
#ifndef VANILLA_AFL
  #include "memory.h"
  #include "decode_inputs.h"
#endif

#ifndef __AFL_FUZZ_TESTCASE_LEN
  ssize_t fuzz_len;
  #define __AFL_FUZZ_TESTCASE_LEN fuzz_len
  unsigned char fuzz_buf[1024000];
  #define __AFL_FUZZ_TESTCASE_BUF fuzz_buf
  #define __AFL_FUZZ_INIT() void sync(void);
  #define __AFL_LOOP(x) ((fuzz_len = read(0, fuzz_buf, sizeof(fuzz_buf))) > 0 ? 1 : 0)
  #define __AFL_INIT() sync()
#endif

__AFL_FUZZ_INIT();


static PGconn *conn = NULL;

int run_cmd(const char *cmd, int printResult, int silentErrors) {
  if (!conn) {
    conn = PQconnectdb(""); //"user = 'postgres'");
 //   printf("Connected: %d\n", PQstatus(conn));
  }


  PGresult *result = PQexec(conn, cmd);
  if (!result) {
    if (!silentErrors) {
      printf("  fatal error fetching result for '%s'\n", cmd);
      printf("  PQErrorMessage: '%s'\n", PQerrorMessage(conn));
    }
    PQclear(result);
    return 1;
  }


  ExecStatusType resStat = PQresultStatus(result);
  if (resStat != PGRES_COMMAND_OK) {
    // printf("  Received result: %d, error message: %s\n", resStat, PQerrorMessage(conn));
    if (!silentErrors) {
      printf("Ran '%s'\n", cmd);
      printf("%s", PQerrorMessage(conn));
    }
    PQclear(result);
    return 1;
  }

  if (printResult) {
    PQprintOpt printOpt = {
          .header = 1,
          .align = 0,
          .standard = 0,
          .html3 = 0,
          .expanded = 1,
          .pager = 1,
          .fieldSep = ",",
          .tableOpt = NULL,
          .caption = NULL,
          .fieldName = NULL
    };
  
    PQprint(stdout, result, &printOpt);
  }

  PQclear(result);

  return 0;
}

void reset_conn() {
  PQfinish(conn);
  conn = NULL;
}

#define RUN_OR_BAIL(cmd) do { int ret = cmd; if (ret) { reset_conn(); continue; } } while(0);

int main(void) {

  int printRes = 0;
  int silentErrors = 1;
  RUN_OR_BAIL(run_cmd("DROP TABLE IF EXISTS errtst", printRes, silentErrors););

  run_cmd("DROP USER IF EXISTS high", printRes, silentErrors);
  run_cmd("DROP USER IF EXISTS low", printRes, silentErrors);
  run_cmd("CREATE USER high", printRes, silentErrors);
  run_cmd("CREATE USER low", printRes, silentErrors);

  run_cmd("CREATE TABLE errtst(a text, b text NOT NULL, c text, secret1 text, secret2 text) PARTITION BY LIST (a);", printRes, silentErrors);
  run_cmd("CREATE TABLE errtst_part_1(secret2 text, c text, a text, b text NOT NULL, secret1 text);", printRes, silentErrors);
  run_cmd("CREATE TABLE errtst_part_2(secret1 text, secret2 text, a text, c text, b text NOT NULL);", printRes, silentErrors);

  run_cmd("ALTER TABLE errtst ATTACH PARTITION errtst_part_1 FOR VALUES IN ('aaa');", printRes, silentErrors);
  run_cmd("ALTER TABLE errtst ATTACH PARTITION errtst_part_2 FOR VALUES IN ('aaaa');", printRes, silentErrors);

  run_cmd("GRANT SELECT (a, b, c) ON TABLE errtst TO low;", printRes, silentErrors);
  run_cmd("GRANT UPDATE (a, b, c) ON TABLE errtst TO low;", printRes, silentErrors);
  run_cmd("GRANT INSERT (a, b, c) ON TABLE errtst TO low;", printRes, silentErrors);

  #ifdef __AFL_HAVE_MANUAL_CONTROL
  __AFL_INIT();
  #endif

  char *buf = __AFL_FUZZ_TESTCASE_BUF;

  while (__AFL_LOOP(10000)) {
    int len =  __AFL_FUZZ_TESTCASE_LEN;

    silentErrors = 1;

    int res = run_cmd("SET SESSION AUTHORIZATION DEFAULT", printRes, silentErrors);
    if (res) break;

    res = run_cmd("DELETE FROM errtst_part_1;", printRes, silentErrors);
    if (res) break;

    uint8_t *public_in, *secret_in;
    uint32_t public_len, secret_len;
#ifdef VANILLA_AFL
    public_in = buf;
    public_len = len / 2;
    secret_in = buf + public_len;
    secret_len = len - public_len;
#else
    find_public_and_secret_inputs((const char *)buf, len, &public_in, &public_len, &secret_in, &secret_len);
#endif

    char *secret1 = malloc(secret_len / 2 + 1);
    char *secret2 = malloc(secret_len / 2 + 1);
    memcpy(secret1, secret_in, secret_len / 2);
    secret1[secret_len / 2] = 0;
    memcpy(secret2, secret_in + secret_len / 2, secret_len / 2);
    secret2[secret_len / 2] = 0;
    
    char *command = malloc(secret_len + 200);
    sprintf(command, "INSERT INTO errtst_part_1 (a, b, c, secret1, secret2) VALUES ('aaa', 'low2', 'low3', '%s', '%s');", secret1, secret2);

    res = run_cmd(command, printRes, silentErrors);

    free(command);
    free(secret1);
    free(secret2);

    if (res) goto cleanup;

    silentErrors = 0;

    run_cmd("SET SESSION AUTHORIZATION low", printRes, silentErrors);

    char *commands = malloc(public_len + 1);
    memcpy(commands, public_in, public_len);
    commands[public_len] = 0;

    char *token = strtok(commands, ";");
    while (token) {
      run_cmd(token, 0, silentErrors);
      token = strtok(NULL, ";");
    }

cleanup:
    free(commands);
#ifndef VANILLA_AFL
    free(public_in);
    free(secret_in);
#endif

  }

  PQfinish(conn);

  return 0;
}

