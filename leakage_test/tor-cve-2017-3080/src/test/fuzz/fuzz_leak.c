#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <assert.h>
#include <string.h>
#include <stddef.h>
#include <limits.h>
#include <time.h>
#include <errno.h>

#include "memory.h"
#include "decode_inputs.h"

#include "fuzzing.h"

#include "or.h"
#include "rendcommon.h"
#include "torlog.h"
//#include "lib/log/log.h"


__AFL_COVERAGE()

int
fuzz_init(void)
{
  return 0;
}

int
fuzz_cleanup(void)
{
  return 0;
}

int
fuzz_main(const uint8_t *data, size_t sz)
{
  uint8_t *public_in, *secret_in;
  uint32_t public_len, secret_len;
  find_public_and_secret_inputs((const char *)data, sz, &public_in, &public_len, &secret_in, &secret_len);

  uint8_t *public_buf = public_in;
  uint32_t public_buf_len = public_len;

  if (public_buf_len < sizeof(circuit_t) + sizeof(int)) {
    printf("Expected public len > %u, was %u bytes\n", sizeof(circuit_t) + sizeof(int), public_buf_len);
    goto free_input_bufs;
  }
  circuit_t *circ = public_buf;
  public_buf += sizeof(circuit_t);
  int command = *public_buf;
  public_buf += sizeof(int);
  public_buf_len = public_len - (public_buf - public_in);

  crypt_path_t *layer_hint = NULL;
  if (public_buf_len >= sizeof(crypt_path_t)) {
    layer_hint = public_buf;
    public_buf += sizeof(crypt_path_t);
    public_buf_len = public_len - (public_buf - public_in);
  }

  uint32_t seed = 0;
  for (int i = 0; i < (secret_len < 4 ? secret_len : 4); i++) {
    seed |= (uint32_t)secret_in[i] << 8 * i;
  }

  init_logging(0);
  log_severity_list_t *s = tor_malloc_zero(sizeof(log_severity_list_t));
  set_log_severity_config(LOG_DEBUG, LOG_ERR, s);
  add_stream_log(s, "<AFL++>", fileno(stdout));
  tor_free(s);

  SEED_MEMORY(seed);
  __AFL_COVERAGE_DISCARD();

  rend_process_relay_cell(circ, layer_hint,
                          command, public_buf_len,
                          public_buf);


free_input_bufs:
  free(public_in);
  free(secret_in);

  return 0;
}
